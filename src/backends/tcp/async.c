#include "async.h"
#include <glib.h>     // for g_thread_pool_new, g_free, g_malloc0_n, g_threa...
#include <stdbool.h>  // for false, true
#include <stddef.h>   // for NULL
#include "debug.h"    // for laik_tcp_always
#include "errors.h"   // for laik_tcp_errors_new, laik_tcp_errors_free, laik...

struct Laik_Tcp_Async {
    GThreadPool*             pool;
    Laik_Tcp_Async_Function* function;
    Laik_Tcp_Errors*         errors;
    void*                    input;
    void*                    output;
};

static char dummy = 0;

static void laik_tcp_async_proxy (__attribute__ ((unused)) void* data, void* userdata) {
    laik_tcp_always (data == &dummy);
    laik_tcp_always (userdata);

    // Get our Laik_Tcp_Async object
    Laik_Tcp_Async* this = userdata;

    // Run the function and store its output back in our Laik_Tcp_Async object
    this->output = this->function (this->input, this->errors);
}

Laik_Tcp_Async* laik_tcp_async_new (Laik_Tcp_Async_Function* function, void* input) {
    laik_tcp_always (function);

    // Create the object
    Laik_Tcp_Async* this = g_new (Laik_Tcp_Async, 1);

    // Initialiaze the object. Note that we use a non-exclusive thread pool [0]
    // which means that we can re-use idle threads left over by other thread
    // pools, including previous calls to this function!
    // [0] https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#g-thread-pool-new
    *this = (Laik_Tcp_Async) {
        .pool     = g_thread_pool_new (laik_tcp_async_proxy, this, 1, false, NULL),
        .function = function,
        .errors   = laik_tcp_errors_new (),
        .input    = input,
        .output   = NULL,
    };

    // Push a dummy task into the the thread pool
    g_thread_pool_push (this->pool, &dummy, NULL);

    return this;
}

void* laik_tcp_async_wait (Laik_Tcp_Async* this, Laik_Tcp_Errors* errors) {
    laik_tcp_always (this);
    laik_tcp_always (errors);

    // Wait for the thread pool to finish its dummy task
    g_thread_pool_free (this->pool, false, true);

    // Get the result of the asynchronous operation
    void* result = this->output;

    // Forward any errors generated by the asynchronous operation
    laik_tcp_errors_push_other (errors, this->errors);

    // Free the Laik_Tcp_Errors variable used by the asynchronous operation
    laik_tcp_errors_free (this->errors);

    // Free the Laik_Tcp_Async structure
    g_free (this);

    // Return the result
    return result;
}
